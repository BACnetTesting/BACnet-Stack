/*####COPYRIGHTBEGIN####
 -------------------------------------------
 Copyright (C) 2005 Steve Karg

 This program is free software; you can redistribute it and/or
 modify it under the terms of the GNU General Public License
 as published by the Free Software Foundation; either version 2
 of the License, or (at your option) any later version.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program; if not, write to:
 The Free Software Foundation, Inc.
 59 Temple Place - Suite 330
 Boston, MA  02111-1307, USA.

 As a special exception, if other files instantiate templates or
 use macros or inline functions from this file, or you compile
 this file and link it with other works to produce a work based
 on this file, this file does not by itself cause the resulting
 work to be covered by the GNU General Public License. However
 the source code for this file must still be made available in
 accordance with section (3) of the GNU General Public License.

 This exception does not invalidate any other reasons why a work
 based on this file might be covered by the GNU General Public
 License.
 *
 *****************************************************************************************
 *
 *   Modifications Copyright (C) 2017 BACnet Interoperability Testing Services, Inc.
 *
 *   July 1, 2017    BITS    Modifications to this file have been made in compliance
 *                           with original licensing.
 *
 *   This file contains changes made by BACnet Interoperability Testing
 *   Services, Inc. These changes are subject to the permissions,
 *   warranty terms and limitations above.
 *   For more information: info@bac-test.com
 *
 *   For access to source code :
 *
 *       info@bac-test.com
 *           or
 *       www.github.com/bacnettesting/bacnet-stack
 *
 *  2018.07.04 EKH Diffed in hints from Binary Value for future reference
 *
 ****************************************************************************************/

#include "configProj.h"

#include <stdint.h>
#include "bacnet/bits.h"
#include "bacnet/bacenum.h"
 /* basic objects, services, TSM */
#include "bacnet/basic/services.h"
#include "bacnet/dcc.h"

#if ( BACNET_CLIENT == 1 ) || (INTRINSIC_REPORTING == 1) || (BACNET_SVC_COV_B == 1)
#include "bacnet/basic/tsm/tsm.h"
#endif

#include "bacnet/basic/object/device.h"

/* Punchlist for EKH */
/*

    2018.05.22 There are now branches for C and C++

    Multiple Datalinks C is active
    Multiple Datalinks C++ ?
    ST Micro C active
    Full Routing C is 'broken'. Needs a way to allocate objects in devices
    Full Routing C++ is active, but objects are generated by IPC calls...


    2017.06.13
    test server, then move on to router layer.
        remember DER flag
        and mac address save in router layer

    2016.10.27 need to put semaphores around stack - two threads now use it

    Lets do some fuzz testing: https://www.evilsocket.net/2015/04/30/fuzzing-with-afl-fuzz-a-practical-example-afl-vs-binutils/
    Put some range checking on writes (e.g. 0-10v on various settings).

    Network number is, what is network number on startup?
        check local router table

        2018.05.07 Idea from Ganssle's newsletter:
    One trick I used last year is to use GCC's '-finstrument-functions' flag which brackets every compiled function with enter/exit function calls.
    You can write an enter function which tests the amount of stack space left. It's not ideal, but it can save a lot of time.
    After I did this for the kernel to track down a problem, one of the application engineers applied the idea to a thread-intensive application and found several potential problems.

        2018.05.09 implement exceptions, unit tests, from http://www.throwtheswitch.org/cexception

 */

/** @file apdu.c  Handles APDU services */

extern int Routed_Device_Service_Approval(
    BACNET_CONFIRMED_SERVICE service,
    int service_argument,
    uint8_t * apdu_buff,
    uint8_t invoke_id);


/* APDU Timeout in Milliseconds */
static uint16_t Timeout_Milliseconds = 10000;
/* Number of APDU Retries */
static uint8_t Number_Of_Retries = 3;

/* a simple table for crossing the services supported */
static BACNET_SERVICES_SUPPORTED
confirmed_service_supported[MAX_BACNET_CONFIRMED_SERVICE] = {
    SERVICE_SUPPORTED_ACKNOWLEDGE_ALARM,
    SERVICE_SUPPORTED_CONFIRMED_COV_NOTIFICATION,
    SERVICE_SUPPORTED_CONFIRMED_EVENT_NOTIFICATION,
    SERVICE_SUPPORTED_GET_ALARM_SUMMARY,
    SERVICE_SUPPORTED_GET_ENROLLMENT_SUMMARY,
    SERVICE_SUPPORTED_SUBSCRIBE_COV,
    SERVICE_SUPPORTED_ATOMIC_READ_FILE,
    SERVICE_SUPPORTED_ATOMIC_WRITE_FILE,
    SERVICE_SUPPORTED_ADD_LIST_ELEMENT,
    SERVICE_SUPPORTED_REMOVE_LIST_ELEMENT,
    SERVICE_SUPPORTED_CREATE_OBJECT,
    SERVICE_SUPPORTED_DELETE_OBJECT,
    SERVICE_SUPPORTED_READ_PROPERTY,
    SERVICE_SUPPORTED_READ_PROP_CONDITIONAL,
    SERVICE_SUPPORTED_READ_PROP_MULTIPLE,
    SERVICE_SUPPORTED_WRITE_PROPERTY,
    SERVICE_SUPPORTED_WRITE_PROP_MULTIPLE,
    SERVICE_SUPPORTED_DEVICE_COMMUNICATION_CONTROL,
    SERVICE_SUPPORTED_PRIVATE_TRANSFER,
    SERVICE_SUPPORTED_TEXT_MESSAGE,
    SERVICE_SUPPORTED_REINITIALIZE_DEVICE,
    SERVICE_SUPPORTED_VT_OPEN,
    SERVICE_SUPPORTED_VT_CLOSE,
    SERVICE_SUPPORTED_VT_DATA,
    SERVICE_SUPPORTED_AUTHENTICATE,
    SERVICE_SUPPORTED_REQUEST_KEY,
    SERVICE_SUPPORTED_READ_RANGE,
    SERVICE_SUPPORTED_LIFE_SAFETY_OPERATION,
    SERVICE_SUPPORTED_SUBSCRIBE_COV_PROPERTY,
    SERVICE_SUPPORTED_GET_EVENT_INFORMATION
};

/* a simple table for crossing the services supported */
static BACNET_SERVICES_SUPPORTED
unconfirmed_service_supported[MAX_BACNET_UNCONFIRMED_SERVICE] = {
    SERVICE_SUPPORTED_I_AM,
    SERVICE_SUPPORTED_I_HAVE,
    SERVICE_SUPPORTED_UNCONFIRMED_COV_NOTIFICATION,
    SERVICE_SUPPORTED_UNCONFIRMED_EVENT_NOTIFICATION,
    SERVICE_SUPPORTED_UNCONFIRMED_PRIVATE_TRANSFER,
    SERVICE_SUPPORTED_UNCONFIRMED_TEXT_MESSAGE,
    SERVICE_SUPPORTED_TIME_SYNCHRONIZATION,
    SERVICE_SUPPORTED_WHO_HAS,
    SERVICE_SUPPORTED_WHO_IS,
    SERVICE_SUPPORTED_UTC_TIME_SYNCHRONIZATION
};

/* Confirmed Function Handlers */
/* If they are not set, they are handled by a reject message */
static confirmed_function Confirmed_Function[MAX_BACNET_CONFIRMED_SERVICE];

/**
 * @brief Set a handler function for the given confirmed service.
 *
 * @param service_choice Service, see SERVICE_CONFIRMED_X enumeration.
 * @param pFunction  Pointer to the function, being in charge of the service.
 */
void apdu_set_confirmed_handler(
    BACNET_CONFIRMED_SERVICE service_choice,
    confirmed_function pFunction)
{
    if (service_choice < MAX_BACNET_CONFIRMED_SERVICE)
    {
        Confirmed_Function[service_choice] = pFunction;
    }
}

/* Allow the APDU handler to automatically reject */
static confirmed_function Unrecognized_Service_Handler;

void apdu_set_unrecognized_service_handler_handler(
    confirmed_function pFunction)
{
    Unrecognized_Service_Handler = pFunction;
}

/* Unconfirmed Function Handlers */
/* If they are not set, they are not handled */
static unconfirmed_function
    Unconfirmed_Function[MAX_BACNET_UNCONFIRMED_SERVICE];

void apdu_set_unconfirmed_handler(
    BACNET_UNCONFIRMED_SERVICE service_choice,
    unconfirmed_function pFunction)
{
    if (service_choice < MAX_BACNET_UNCONFIRMED_SERVICE)
    {
        Unconfirmed_Function[service_choice] = pFunction;
    }
}


bool apdu_service_supported(
    BACNET_SERVICES_SUPPORTED service_supported)
{
    int i ;
    bool status = false;
    bool found = false;

    if (service_supported < MAX_BACNET_SERVICES_SUPPORTED)
    {
        /* is it a confirmed service? */
        for (i = 0; i < MAX_BACNET_CONFIRMED_SERVICE; i++)
        {
            if (confirmed_service_supported[i] == service_supported)
            {
                found = true;
                if (Confirmed_Function[i] != NULL)
                {
                    status = true;
                }
                break;
            }
        }

        if (!found)
        {
            /* is it an unconfirmed service? */
            for (i = 0; i < MAX_BACNET_UNCONFIRMED_SERVICE; i++)
            {
                if (unconfirmed_service_supported[i] == service_supported)
                {
                    if (Unconfirmed_Function[i] != NULL)
                    {
                        status = true;
                    }
                    break;
                }
            }
        }
    }
    return status;
}

/** Function to translate a SERVICE_SUPPORTED_ enum to its SERVICE_CONFIRMED_
 *  or SERVICE_UNCONFIRMED_ index.
 *  Useful with the bactext_confirmed_service_name() functions.
 *
 * @param service_supported [in] The SERVICE_SUPPORTED_ enum value to convert.
 * @param index [out] The SERVICE_CONFIRMED_ or SERVICE_UNCONFIRMED_ index,
 *                    if found.
 * @param bIsConfirmed [out] True if index is a SERVICE_CONFIRMED_ type.
 * @return True if a match was found and index and bIsConfirmed are valid.
 */
bool apdu_service_supported_to_index(
    BACNET_SERVICES_SUPPORTED service_supported,
    uint16_t *index,
    bool *bIsConfirmed)
{
    uint16_t i ;
    bool found = false;

    *bIsConfirmed = false;
    if (service_supported < MAX_BACNET_SERVICES_SUPPORTED)
    {
        /* is it a confirmed service? */
        for (i = 0; i < MAX_BACNET_CONFIRMED_SERVICE; i++)
        {
            if (confirmed_service_supported[i] == service_supported)
            {
                found = true;
                *index = i;
                *bIsConfirmed = true;
                break;
            }
        }

        if (!found)
        {
            /* is it an unconfirmed service? */
            for (i = 0; i < MAX_BACNET_UNCONFIRMED_SERVICE; i++)
            {
                if (unconfirmed_service_supported[i] == service_supported)
                {
                    found = true;
                    *index = i;
                    break;
                }
            }
        }
    }
    return found;
}

/* Confirmed ACK Function Handlers */
static confirmed_ack_function
    Confirmed_ACK_Function[MAX_BACNET_CONFIRMED_SERVICE];

void apdu_set_confirmed_simple_ack_handler(
    BACNET_CONFIRMED_SERVICE service_choice,
    confirmed_simple_ack_function pFunction)
{
    switch (service_choice)
    {
    case SERVICE_CONFIRMED_ACKNOWLEDGE_ALARM:
    case SERVICE_CONFIRMED_COV_NOTIFICATION:
    case SERVICE_CONFIRMED_EVENT_NOTIFICATION:
    case SERVICE_CONFIRMED_SUBSCRIBE_COV:
    case SERVICE_CONFIRMED_SUBSCRIBE_COV_PROPERTY:
    case SERVICE_CONFIRMED_LIFE_SAFETY_OPERATION:
        /* Object Access Services */
    case SERVICE_CONFIRMED_ADD_LIST_ELEMENT:
    case SERVICE_CONFIRMED_REMOVE_LIST_ELEMENT:
    case SERVICE_CONFIRMED_DELETE_OBJECT:
    case SERVICE_CONFIRMED_WRITE_PROPERTY:
    case SERVICE_CONFIRMED_WRITE_PROP_MULTIPLE:
        /* Remote Device Management Services */
    case SERVICE_CONFIRMED_DEVICE_COMMUNICATION_CONTROL:
    case SERVICE_CONFIRMED_TEXT_MESSAGE:
    case SERVICE_CONFIRMED_REINITIALIZE_DEVICE:
        /* Virtual Terminal Services */
    case SERVICE_CONFIRMED_VT_CLOSE:
        /* Security Services */
    case SERVICE_CONFIRMED_REQUEST_KEY:
        Confirmed_ACK_Function[service_choice] =
            (confirmed_ack_function)pFunction;
        break;
    default:
        break;
    }
}

void apdu_set_confirmed_ack_handler(
    BACNET_CONFIRMED_SERVICE service_choice,
    confirmed_ack_function pFunction)
{
    switch (service_choice)
    {
    case SERVICE_CONFIRMED_GET_ALARM_SUMMARY:
    case SERVICE_CONFIRMED_GET_ENROLLMENT_SUMMARY:
    case SERVICE_CONFIRMED_GET_EVENT_INFORMATION:
        /* File Access Services */
    case SERVICE_CONFIRMED_ATOMIC_READ_FILE:
    case SERVICE_CONFIRMED_ATOMIC_WRITE_FILE:
        /* Object Access Services */
    case SERVICE_CONFIRMED_CREATE_OBJECT:
    case SERVICE_CONFIRMED_READ_PROPERTY:
    case SERVICE_CONFIRMED_READ_PROP_CONDITIONAL:
    case SERVICE_CONFIRMED_READ_PROP_MULTIPLE:
    case SERVICE_CONFIRMED_READ_RANGE:
        /* Remote Device Management Services */
    case SERVICE_CONFIRMED_PRIVATE_TRANSFER:
        /* Virtual Terminal Services */
    case SERVICE_CONFIRMED_VT_OPEN:
    case SERVICE_CONFIRMED_VT_DATA:
        /* Security Services */
    case SERVICE_CONFIRMED_AUTHENTICATE:
        Confirmed_ACK_Function[service_choice] = pFunction;
        break;
    default:
        break;
    }
}

// 'allow' these into the BACnet Stack Library - they are required by the command line tools
#if ( BACNET_CLIENT == 1 )
static error_function Error_Function[MAX_BACNET_CONFIRMED_SERVICE];

void apdu_set_error_handler(
    BACNET_CONFIRMED_SERVICE service_choice,
    error_function pFunction)
{
    if (service_choice < MAX_BACNET_CONFIRMED_SERVICE)
    {
        Error_Function[service_choice] = pFunction;
    }
}

static abort_function Abort_Function;

void apdu_set_abort_handler(
    abort_function pFunction)
{
    Abort_Function = pFunction;
}

static reject_function Reject_Function;

void apdu_set_reject_handler(
    reject_function pFunction)
{
    Reject_Function = pFunction;
}
#endif // ( BACNET_CLIENT == 1 )


uint16_t apdu_decode_confirmed_service_request(
    uint8_t * apdu,     /* APDU data */
    uint16_t apdu_len,
    BACNET_CONFIRMED_SERVICE_DATA *service_data,
    BACNET_CONFIRMED_SERVICE *service_choice,
    uint8_t **service_request,
    uint16_t *service_request_len)
{
    uint16_t len = 0;   /* counts where we are in PDU */

    if (apdu_len >= 3)
    {
        service_data->segmented_message = (apdu[0] & BIT(3)) ? true : false;
        service_data->more_follows = (apdu[0] & BIT(2)) ? true : false;
        service_data->segmented_response_accepted =
            (apdu[0] & BIT(1)) ? true : false;
        service_data->max_segs = decode_max_segs(apdu[1]);
        service_data->max_resp = decode_max_apdu(apdu[1]);
        service_data->invoke_id = apdu[2];
        len = 3;
        if (service_data->segmented_message)
        {
            if (apdu_len >= (len + 2))
            {
                service_data->sequence_number = apdu[len++];
                service_data->proposed_window_number = apdu[len++];
            }
            else
            {
                return 0;
            }
        }
        if (apdu_len == (len + 1))
        {
            /* no request data as seen with Inneasoft BACnet Explorer */
            *service_choice = (BACNET_CONFIRMED_SERVICE)apdu[len++];
            *service_request = NULL;
            *service_request_len = 0;
        }
        else if (apdu_len >= (len + 2))
        {
            *service_choice = (BACNET_CONFIRMED_SERVICE)apdu[len++];
            *service_request = &apdu[len];
            *service_request_len = apdu_len - len;
        }
        else
        {
            return 0;
        }
    }

    return len;
}

uint16_t apdu_timeout(
    void)
{
    return Timeout_Milliseconds;
}

void apdu_timeout_set(
    uint16_t milliseconds)
{
    Timeout_Milliseconds = milliseconds;
}

uint8_t apdu_retries(
    void)
{
    return Number_Of_Retries;
}

void apdu_retries_set(
    uint8_t value)
{
    Number_Of_Retries = value;
}


/* When network communications are completely disabled,
   only DeviceCommunicationControl and ReinitializeDevice APDUs
   shall be processed and no messages shall be initiated.
   When the initiation of communications is disabled,
   all APDUs shall be processed and responses returned as
   required... */
static bool apdu_confirmed_dcc_disabled(
    DEVICE_OBJECT_DATA *pDev,
    BACNET_CONFIRMED_SERVICE service_choice)
{
    bool status = false;

    if (dcc_communication_disabled(pDev))
    {
        switch (service_choice)
        {
        case SERVICE_CONFIRMED_DEVICE_COMMUNICATION_CONTROL:
        case SERVICE_CONFIRMED_REINITIALIZE_DEVICE:
            break;
        default:
            status = true;
            break;
        }
    }

    return status;
}


/**
 * When network communications are completely disabled,
 * only DeviceCommunicationControl and ReinitializeDevice APDUs
 * shall be processed and no messages shall be initiated.
 * If the request is valid and the 'Enable/Disable' parameter is
 * DISABLE_INITIATION, the responding BACnet-user shall
 * discontinue the initiation of messages except for I-Am
 * requests issued in accordance with the Who-Is service procedure.
 *
 * @param service_choice  Service, like SERVICE_UNCONFIRMED_WHO_IS
 *
 * @return true, if being disabled.
 */
static bool apdu_unconfirmed_dcc_disabled(
    DEVICE_OBJECT_DATA *pDev,
    BACNET_UNCONFIRMED_SERVICE service_choice)
{
    bool status = false;

    if (dcc_communication_disabled(pDev))
    {
        /* there are no Unconfirmed messages that
           can be processed in this state */
        status = true;
    }
    else if (dcc_communication_initiation_disabled(pDev))
    {
        /* WhoIs will be processed and I-Am initiated as response. */
        switch (service_choice)
        {
        case SERVICE_UNCONFIRMED_WHO_IS:
            break;
        default:
            status = true;
            break;
        }
    }

    return status;
}


/** Process the APDU header and invoke the appropriate service handler
 * to manage the received request.
 * Almost all requests and ACKs invoke this function.
 * @ingroup MISCHNDLR
 *
 * @param src [in] The BACNET_ADDRESS of the message's source.
 * @param apdu [in] The apdu portion of the request, to be processed.
 * @param apdu_len [in] The total (remaining) length of the apdu.
 */
void apdu_handler(
    DEVICE_OBJECT_DATA *pDevLocal,
    BACNET_ROUTE * src,
    uint8_t * apdu,     /* APDU data */
    uint16_t apdu_len)
{
    BACNET_CONFIRMED_SERVICE_DATA service_data;
    BACNET_UNCONFIRMED_SERVICE unconf_service_choice;
    BACNET_CONFIRMED_SERVICE confirmed_service_choice;
    uint8_t * service_request;
    uint16_t service_request_len;
    BACNET_PDU_TYPE pduType = (BACNET_PDU_TYPE)(apdu[0] & 0xF0);
#if ( BACNET_CLIENT == 1 )
    BACNET_CONFIRMED_SERVICE_ACK_DATA service_ack_data;
    int len;        /* counts where we are in PDU */
    uint8_t tag_number;
    uint16_t len_value;
    uint32_t error_code;
    uint32_t error_class;
    BACNET_ABORT_REASON reason;
    bool server;
#endif

    // see cr39582345720345720
    // there are two main types of APDU: Those that are 'polls' 'writes' (original/outgoing) and incoming
    // for incoming, we need to identify the remote device that is a response/ack/error, presumably to an outstanding
    // poll (etc).

    switch (pduType)
    {
    case PDU_TYPE_CONFIRMED_SERVICE_REQUEST:
        (void)apdu_decode_confirmed_service_request(
            &apdu[0],
            apdu_len,
            &service_data,
            &confirmed_service_choice,
            &service_request,
            &service_request_len);
        if (apdu_confirmed_dcc_disabled(pDevLocal, confirmed_service_choice))
        {
            /* When network communications are completely disabled,
               only DeviceCommunicationControl and ReinitializeDevice
               APDUs shall be processed and no messages shall be
               initiated. */
            return;
        }
        if ((confirmed_service_choice < MAX_BACNET_CONFIRMED_SERVICE) &&
            (Confirmed_Function[confirmed_service_choice]))
        {
            Confirmed_Function[confirmed_service_choice](pDevLocal, service_request,
                service_request_len, src, &service_data);
        }
        else if (Unrecognized_Service_Handler)
        {
            Unrecognized_Service_Handler(pDevLocal, service_request,
                service_request_len, src, &service_data);
        }
        return;

    case PDU_TYPE_UNCONFIRMED_SERVICE_REQUEST:
        if (apdu_len >= 2)
        {

            /* TXINTO_ED: Here the code is accessing APDU[2] (third byte),
             * but the BACWI sent by the raspberry has only two bytes
             see https://docs.google.com/document/d/1MaNGcZ4GnPaKNo91rZp9dslmtvm6Ab2fSyg1oTkPL0s/edit?usp=sharing
             page 12*/
             // ed_txinto - I believe you discovered a bug in the Karg code, and he has already fixed it
             // so I have now transferred the latest Karg code into this module for you
             // BUT
             // I had to rename apdu.c to h_apdu.c to match Karg's new name
             // AND move apdu.c from /bacnet to h_apdu.c in /bacnet/basic/service
             // and I included some cosmetics... Please recompile and test.

             // txinto_ed I've checked and debugged he code, and the apdu[2] is 
             // wrongly accessed here, the apdu_len >= 2 is not protecting 
             // when you receive a whois request (apdu == 2), the service_request 
             // will contain what?
             // Moreover, the service_request is receiving a reference (not a value)
             // use of parenthesis will make it more readable.  It is strange code
             // I trust there will be an strong motivation for doing it this way.

             // ed2txinto - yes. service_request is a pointer to 'whatever remains of a long message (more than 2 bytes)
             // in kargs case, it points to garbage in the remainder of the buffer
             // I did a quick check of handler_who_is() and karg checks service_request_len before taking action,
             // so for a check of one instance, it seems he can get away with it.
             //
             // It will work with fixed buffers (like Karg is currently using)
             // But later, when I start adding our routing layers, you will see allocated buffers.... of exactly
             // the size of the incoming packets, so this pointer allocation will segfault (or valgrind will find it)

             // Don't fix it now, but leave these comments for later when I start to patch in more of our 
             // routing layers, and once those are patched in, we should double check all of this.

             // Well spotted.


            unconf_service_choice = (BACNET_UNCONFIRMED_SERVICE)apdu[1];
            service_request = &apdu[2];
            service_request_len = apdu_len - 2;
            if (apdu_unconfirmed_dcc_disabled(pDevLocal, unconf_service_choice))
            {
                /* When network communications are disabled,
                   only DeviceCommunicationControl and
                   ReinitializeDevice APDUs shall be processed and no
                   messages shall be initiated. If communications have
                   been initiation disabled, then WhoIs may be
                   processed. */
                return;
            }
            if (unconf_service_choice < MAX_BACNET_UNCONFIRMED_SERVICE)
            {
                if (Unconfirmed_Function[unconf_service_choice])
                {
                    Unconfirmed_Function[unconf_service_choice](
                        pDevLocal,
                        service_request,
                        service_request_len,
                        src);
                }
            }
            else
            {
                panic();
            }
            return;
        }

        uint8_t response_invoke_id = apdu[1];

        switch (pduType)
        {
        case PDU_TYPE_SIMPLE_ACK:
#if ( BACNET_CLIENT == 1 ) || ( BACNET_SVC_COV_B == 1 )
            if (apdu_len >= 3)
            {
                confirmed_service_choice = (BACNET_CONFIRMED_SERVICE)apdu[2];

                switch (confirmed_service_choice)
                {
                case SERVICE_CONFIRMED_ACKNOWLEDGE_ALARM:
                case SERVICE_CONFIRMED_COV_NOTIFICATION:
                case SERVICE_CONFIRMED_EVENT_NOTIFICATION:
                case SERVICE_CONFIRMED_SUBSCRIBE_COV:
                case SERVICE_CONFIRMED_SUBSCRIBE_COV_PROPERTY:
                case SERVICE_CONFIRMED_LIFE_SAFETY_OPERATION:
                    /* Object Access Services */
                case SERVICE_CONFIRMED_ADD_LIST_ELEMENT:
                case SERVICE_CONFIRMED_REMOVE_LIST_ELEMENT:
                case SERVICE_CONFIRMED_DELETE_OBJECT:
                case SERVICE_CONFIRMED_WRITE_PROPERTY:
                case SERVICE_CONFIRMED_WRITE_PROP_MULTIPLE:
                    /* Remote Device Management Services */
                case SERVICE_CONFIRMED_DEVICE_COMMUNICATION_CONTROL:
                case SERVICE_CONFIRMED_REINITIALIZE_DEVICE:
                case SERVICE_CONFIRMED_TEXT_MESSAGE:
                    /* Virtual Terminal Services */
                case SERVICE_CONFIRMED_VT_CLOSE:
                    /* Security Services */
                case SERVICE_CONFIRMED_REQUEST_KEY:
                    if (Confirmed_ACK_Function[confirmed_service_choice] != NULL)
                    {
                        ((confirmed_simple_ack_function)
                            Confirmed_ACK_Function[confirmed_service_choice]) (
                                src,
                                response_invoke_id);
                    }
                    tsm_free_invoke_id(pDevLocal, response_invoke_id);
                    break;
                default:
                    break;
                }
            }
            break;

        case PDU_TYPE_COMPLEX_ACK:
            if (apdu_len >= 3)
            {
                service_ack_data.segmented_message =
                    (apdu[0] & BIT(3)) ? true : false;
                service_ack_data.more_follows =
                    (apdu[0] & BIT(2)) ? true : false;
                service_ack_data.invoke_id = response_invoke_id;
                service_request_len = 2;
                if (service_ack_data.segmented_message)
                {
                    service_ack_data.sequence_number = apdu[service_request_len++];
                    service_ack_data.proposed_window_number = apdu[service_request_len++];
                }
                confirmed_service_choice = (BACNET_CONFIRMED_SERVICE)apdu[service_request_len++];
                service_request = &apdu[service_request_len];
                service_request_len = apdu_len - service_request_len;

                switch (confirmed_service_choice)
                {
                case SERVICE_CONFIRMED_GET_ALARM_SUMMARY:
                case SERVICE_CONFIRMED_GET_ENROLLMENT_SUMMARY:
                case SERVICE_CONFIRMED_GET_EVENT_INFORMATION:
                    /* File Access Services */
                case SERVICE_CONFIRMED_ATOMIC_READ_FILE:
                case SERVICE_CONFIRMED_ATOMIC_WRITE_FILE:
                    /* Object Access Services */
                case SERVICE_CONFIRMED_CREATE_OBJECT:
                case SERVICE_CONFIRMED_READ_PROPERTY:
                case SERVICE_CONFIRMED_READ_PROP_CONDITIONAL:
                case SERVICE_CONFIRMED_READ_PROP_MULTIPLE:
                case SERVICE_CONFIRMED_READ_RANGE:
                case SERVICE_CONFIRMED_PRIVATE_TRANSFER:
                    /* Virtual Terminal Services */
                case SERVICE_CONFIRMED_VT_OPEN:
                case SERVICE_CONFIRMED_VT_DATA:
                    /* Security Services */
                case SERVICE_CONFIRMED_AUTHENTICATE:
                    if (Confirmed_ACK_Function[confirmed_service_choice] != NULL)
                    {
                        (Confirmed_ACK_Function[confirmed_service_choice])(
                            service_request, service_request_len, src,
                            &service_ack_data);
                    }
                    tsm_free_invoke_id(pDevLocal, response_invoke_id);
                    break;
                default:
                    break;
                }
            }
            break;

        case PDU_TYPE_SEGMENT_ACK:
            /* FIXME: what about a denial of service attack here?
               we could check src to see if that matched the tsm */
            tsm_free_invoke_id(pDevLocal, response_invoke_id);
            break;

        case PDU_TYPE_ERROR:
            if (apdu_len >= 3)
            {
                confirmed_service_choice = (BACNET_CONFIRMED_SERVICE)apdu[2];
                len = 3;

                /* FIXME: Currently special case for C_P_T but there are
                   others which may need consideration such as
                   ChangeList-Error, CreateObject-Error,
                   WritePropertyMultiple-Error and VTClose_Error but they
                   may be left as is for now until support for these
                   services is added */

                if (confirmed_service_choice == SERVICE_CONFIRMED_PRIVATE_TRANSFER)
                {     /* skip over opening tag 0 */
                    if (decode_is_opening_tag_number(&apdu[len], 0))
                    {
                        len++;  /* a tag number of 0 is not extended so only one octet */
                    }
                }

                if (len < apdu_len)
                {
                    len += decode_tag_number_and_value(
                        &apdu[len], &tag_number, &len_value);

                    if (len < apdu_len)
                    {
                        /* FIXME: we could validate that the tag is
                         * enumerated... */
                        len += decode_enumerated(
                            &apdu[len], len_value, &error_class);

                        if (len < apdu_len)
                        {
                            len += decode_tag_number_and_value(
                                &apdu[len], &tag_number, &len_value);

                            if (len < apdu_len)
                            {
                                /* FIXME: we could validate that the tag is
                                 * enumerated... */
                                len += decode_enumerated(
                                    &apdu[len], len_value, &error_code);

                                if (confirmed_service_choice == SERVICE_CONFIRMED_PRIVATE_TRANSFER)
                                {     /* skip over closing tag 0 */
                                    if (len < apdu_len)
                                    {
                                        /* skip over closing tag 0 */
                                        if (decode_is_closing_tag_number(
                                            &apdu[len], 0))
                                        {
                                            len++; /* a tag number of 0 is
                                                      not extended so only
                                                      one octet */
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                if (confirmed_service_choice < MAX_BACNET_CONFIRMED_SERVICE)
                {
                    if (Error_Function[service_choice])
                    {
                        Error_Function[service_choice](src, response_invoke_id,
                            (BACNET_ERROR_CLASS)error_class,
                            (BACNET_ERROR_CODE)error_code);
                    }
                }
                tsm_free_invoke_id(pDevLocal, response_invoke_id);
            }
            break;

        case PDU_TYPE_REJECT:
            if (apdu_len >= 3)
            {
                reason = apdu[2];
                if (Reject_Function)
                {
                    Reject_Function(src, response_invoke_id, reason);
                }
                tsm_free_invoke_id(pDevLocal, response_invoke_id);
            }
            break;

        case PDU_TYPE_ABORT:
            if (apdu_len >= 3)
            {
                server = apdu[0] & 0x01;
                reason = (BACNET_ABORT_REASON)apdu[2];
                if (Abort_Function)
                {
                    Abort_Function(src, response_invoke_id, reason, server);
                }
                tsm_free_invoke_id(pDevLocal, response_invoke_id);
            }
#endif  // BACNET_CLIENT
            break;
        default:
            panic();
            break;
        }
    }
}
